#include "MK64F12.h"
#include "DataTypeDefinitions.h"
//#include <stdio.h>

uint8 adcResult=0;
float resultF = 0;
float resultC = 0;


void ADC_Init(void){
	
	//ACTIVATES CLOCK GATING FOR ADC0
	SIM->SCGC6 |= SIM_SCGC6_ADC0_MASK;	
	/**
	 * FIRST FLAG CONFIGURE DIVIDE RATIO AS 8 AND THE CLOCK RATE IS INPUT CLOCK / 8
	 * SECOND FLAG CONFIGURES LONG SAMPLE TIME
	 * THIRD FLAG CONFIGURES MODE 0: CONVERSION MODE SELECT IS THE ADC RESOLUTION IN THIS CASE DIFF IS 0
	 * SO ITS A SINGLE ENDED 8 BIT CONVERSION
	 * FOURTH FLAG SAYS WE ARE GOING TO USE BUS CLOCK TO  GENERATE THE INTERNAL CLOCK
	 */
	ADC0->CFG1 = ADC_CFG1_ADIV(3)|ADC_CFG1_ADLSMP_MASK |ADC_CFG1_MODE(0)|ADC_CFG1_ADICLK(0);
	/**
	 * IN ADDITION TO THE WAY OF USING ADC WE HAD TO CONFIGURES ANOTHER REGISTER SC3
	 *
	 * FIRST FLAG ENABLES HARDWARE AVERAGE FUNCTION
	 * AND RECOLECTS THE MAX AVERAGE SAMPLES (32) WITH THE NEXT FLAG
	 */
	ADC0->SC3 = ADC_SC3_AVGE_MASK |ADC_SC3_AVGS(1);
}

void ADC_result(void)
{

	 //SC1A CAN BE USED FOR HW AND TRIGGER MODE
	 //PARA PERMITIR CONVERSIONES SEGUIDAS EL ADC CUENTA CON MAS DE UN SC1 PARA CADA CONVERSION
	 //AD18 IS SELECTED AS INPUT
	 //WITH A 14 ON IT, WILL CONFIGURE THE PTC0
	 ADC0->SC1[0]= ADC_SC1_ADCH(12);

	 //ONLY WHEN A CONVERSION IS COMPLETE THIS CONDITION WILL BE COMPLETED
	 while(0 == (ADC0->SC1[0] & ADC_SC1_COCO_MASK));

	 //THE FLAG WILL BE ACTIVE AND WE WOULD SAVE THE CONVERSION VALUE
	 //REGISTER R CONTAINS THE RESULT CONVERSION OF ADC BUT IN ITS RESPECTIVILY SC1[N]
	 adcResult = ADC0->R[0];
	 resultC = adcResult * 1.25;
	 resultF = (resultC * 1.8)+32;
	 //SO THEN THIS FUNCTION RETURNS AN 8 BIT VARIABLE SET BY ADC CONVERSION SOMEHOW
}

uint32 getCelsius(void)
{

	return (uint32)resultC;

}

uint32 getFarenheit(void)
{

	return (uint32)resultF;

}
